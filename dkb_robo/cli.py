import click
from . import dkb_robo
from datetime import date

DATE_FORMAT = "%d.%m.%Y"


@click.group()
@click.option(
    "--debug",
    "-d",
    default=False,
    help="Show additional debugging",
    is_flag=True,
    envvar="DKB_DEBUG",
)
@click.option(
    "--use-tan",
    "-t",
    default=False,
    help="dbk-robo will ask for a TAN (generated by either ChipTan or TAN2go) during login",
    is_flag=True,
    envvar="DKB_USE_TAN",
)
@click.option(
    "--username",
    "-u",
    required=True,
    type=str,
    help="username to access the dkb portal",
    envvar="DKB_USERNAME",
)
@click.option(
    "--password",
    "-p",
    prompt=True,
    hide_input=True,
    type=str,
    help="corresponding login password",
    envvar="DKB_PASSWORD",
)
@click.option(
    "--format",
    default="pprint",
    type=click.Choice(["pprint", "table", "csv", "json"]),
    help="output format to use",
    envvar="DKB_FORMAT",
)
@click.pass_context
def main(ctx, debug, use_tan, username, password, format):
    ctx.ensure_object(dict)
    ctx.obj["DEBUG"] = debug
    ctx.obj["USE_TAN"] = use_tan
    ctx.obj["USERNAME"] = username
    ctx.obj["PASSWORD"] = password
    ctx.obj["FORMAT"] = _load_format(format)


@main.command()
@click.pass_context
def accounts(ctx):
    try:
        with _login(ctx) as dkb:
            accounts = dkb.account_dic
            for _, value in accounts.items():
                del value["details"]
                del value["transactions"]
            ctx.obj["FORMAT"](accounts.values())
    except dkb_robo.DKBRoboError as e:
        click.echo(e.args[0], err=True)


@main.command()
@click.pass_context
@click.option(
    "--name",
    "-n",
    type=str,
    help="Name of the account to fetch transactions for",
    envvar="DKB_TRANSACTIONS_ACCOUNT_NAME",
)
@click.option(
    "--account",
    "-a",
    type=str,
    help="Account to fetch transactions for",
    envvar="DKB_TRANSACTIONS_ACCOUNT",
)
@click.option(
    "--transaction-type",
    "-t",
    default="booked",
    type=click.Choice(["booked", "reserved"]),
    help="The type of transactions to fetch",
    envvar="DKB_TRANSACTIONS_TYPE",
)
@click.option(
    "--date-from",
    type=click.DateTime(formats=[DATE_FORMAT]),
    default=date.today().strftime(DATE_FORMAT),
)
@click.option(
    "--date-to",
    type=click.DateTime(formats=[DATE_FORMAT]),
    default=date.today().strftime(DATE_FORMAT),
)
def transactions(ctx, name, account, transaction_type, date_from, date_to):
    if name is not None and account is None:
        account_filter = lambda acct: acct["name"] == name
    elif account is not None and name is None:
        account_filter = lambda acct: acct["account"] == account
    else:
        raise click.UsageError("One of --name or --account must be provided.", ctx)

    try:
        with _login(ctx) as dkb:
            accounts = dkb.account_dic
            filtered_accounts = [
                acct for acct in accounts.values() if account_filter(acct)
            ]
            if len(filtered_accounts) == 0:
                click.echo(f"No account found matching '{name or account}'", err=True)
                return
            the_account = filtered_accounts[0]
            transactions = dkb.get_transactions(
                the_account["transactions"],
                the_account["type"],
                date_from.strftime(DATE_FORMAT),
                date_to.strftime(DATE_FORMAT),
                transaction_type=transaction_type,
            )
            ctx.obj["FORMAT"](transactions)

    except dkb_robo.DKBRoboError as e:
        click.echo(e.args[0], err=True)


@main.command()
@click.pass_context
def last_login(ctx):
    try:
        with _login(ctx) as dkb:
            ctx.obj["FORMAT"]([{"last_login": dkb.last_login}])
    except dkb_robo.DKBRoboError as e:
        click.echo(e.args[0], err=True)


@main.command()
@click.pass_context
def credit_limits(ctx):
    try:
        with _login(ctx) as dkb:
            limits = dkb.get_credit_limits()
            limits = [{"account": k, "limit": v} for k, v in limits.items()]
            ctx.obj["FORMAT"](limits)
    except dkb_robo.DKBRoboError as e:
        click.echo(e.args[0], err=True)


@main.command()
@click.pass_context
def standing_orders(ctx):
    try:
        with _login(ctx) as dkb:
            ctx.obj["FORMAT"](dkb.get_standing_orders())
    except dkb_robo.DKBRoboError as e:
        click.echo(e.args[0], err=True)


def _load_format(format):
    if format == "pprint":
        from pprint import pprint

        return lambda data: pprint(data)
    elif format == "table":
        import tabulate

        return lambda data: click.echo(
            tabulate.tabulate(data, headers="keys", tablefmt="grid")
        )
    elif format == "csv":
        import sys
        import csv

        def formatter(data):
            if len(data) == 0:
                return
            writer = csv.DictWriter(sys.stdout, data[0].keys())
            writer.writeheader()
            writer.writerows(data)

        return formatter
    elif format == "json":
        import json

        return lambda data: click.echo(json.dumps(data, indent=2))

    else:
        raise Exception(f"Unknown format: {format}")


def _login(ctx):
    return dkb_robo.DKBRobo(
        ctx.obj["USERNAME"], ctx.obj["PASSWORD"], ctx.obj["USE_TAN"], ctx.obj["DEBUG"]
    )
